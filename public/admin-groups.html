<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Admin — Groups</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="/css/style.css">
  <!-- Admin CSS (load in this order after style.css) -->
  <link rel="stylesheet" href="/css/admin-base.css">
  <link rel="stylesheet" href="/css/admin-bookings.css">
  <link rel="stylesheet" href="/css/admin-payments.css">
  <link rel="stylesheet" href="/css/admin-partners.css">
  <link rel="stylesheet" href="/css/admin-responsive.css">
  <link rel="stylesheet" href="/css/admin-tuning.css">
</head>
<body class="site-gradient admin-partners">
  <header>
    <div class="controls">
      <label>Trip: <input id="tripId" placeholder="trip_id"></label>
      <label>Date: <input id="date" type="date"></label>
      <button id="load">Load</button>
      <button id="auto">Auto-group</button>
      <button id="newGroup">New group</button>
    </div>
  </header>

  <div class="columns">
    <div class="panel">
      <h3>Unassigned travelers</h3>
      <div id="pool" class="list" data-list="pool"></div>
    </div>
    <div class="panel">
      <h3>Groups</h3>
      <div id="groups"></div>
    </div>
  </div>

  <script>
  (function(){
    const qs = new URLSearchParams(location.search);
    const tripIdEl = document.getElementById('tripId');
    const dateEl = document.getElementById('date');
    tripIdEl.value = qs.get('trip_id') || '';
    dateEl.value = qs.get('date') || new Date().toISOString().slice(0,10);

    const pool = document.getElementById('pool');
    const groupsWrap = document.getElementById('groups');

    function travItem(t){
      const el = document.createElement('div');
      el.className = 'trav';
      el.draggable = true;
      el.dataset.email = t.email;
      el.innerHTML = `<div><strong>${t.name||t.email}</strong></div>
        <div class="meta">
          <span>Lang: ${t.language||'—'}</span>
          <span>Type: ${t.traveler_type||'—'}</span>
          <span>Soc: ${t.sociality||'—'}</span>
          <span>Avg: ${t.average_rating!=null?Number(t.average_rating).toFixed(1):'—'}</span>
        </div>`;
      wireDrag(el);
      return el;
    }

    function groupBox(g){
      const box = document.createElement('div');
      box.className = 'group' + (g.locked? ' group-locked' : '');
      box.dataset.id = g.id || '';
      const header = document.createElement('div');
      header.className = 'group-header';
      header.innerHTML = `<div>Group ${g.id ? g.id.slice(0,6) : '(new)'} — <small>${g.locked? 'Locked' : 'Unlocked'}</small></div>`;
      const actions = document.createElement('div');
      const lockBtn = document.createElement('button'); lockBtn.textContent = 'Lock group'; lockBtn.disabled = !!g.locked;
      lockBtn.addEventListener('click', ()=> lockGroup(g.id));
      actions.appendChild(lockBtn);
      header.appendChild(actions);
      box.appendChild(header);

      const list = document.createElement('div');
      list.className = 'list';
      list.dataset.list = 'group';
      box.appendChild(list);
      g.travelers.forEach(e => list.appendChild(travItem(e)));
      wireDrop(list);
      return box;
    }

    function wireDrag(el){
      el.addEventListener('dragstart', (e)=>{ el.classList.add('dragging'); e.dataTransfer.setData('text/plain', el.dataset.email); });
      el.addEventListener('dragend', ()=>{ el.classList.remove('dragging'); });
    }
    function wireDrop(list){
      list.addEventListener('dragover', (e)=>{ e.preventDefault(); });
      list.addEventListener('drop', (e)=>{
        e.preventDefault();
        const email = e.dataTransfer.getData('text/plain');
        if (!email) return;
        // avoid duplicates within the same list
        if ([...list.querySelectorAll('.trav')].some(x=>x.dataset.email===email)) return;
        const dragged = document.querySelector(`.trav[data-email="${CSS.escape(email)}"]`);
        if (dragged) list.appendChild(dragged);
      });
    }

    async function load(){
      const trip_id = tripIdEl.value.trim(); const date = dateEl.value.trim();
      if (!trip_id || !date) return alert('Fill trip_id and date');
      const r = await fetch(`/admin/groups?trip_id=${encodeURIComponent(trip_id)}&date=${encodeURIComponent(date)}`, { headers: { 'Accept': 'application/json' } });
      const j = await r.json();
      pool.innerHTML = '';
      (j.travelers||[]).forEach(t => pool.appendChild(travItem(t)));
      groupsWrap.innerHTML = '';
      (j.groups||[]).forEach(g => {
        // Enrich group travelers with profile meta; groups store emails only
        const list = (Array.isArray(g.travelers) ? g.travelers : []).map(email => (j.travelers||[]).find(t => t.email===email) || { email });
        groupsWrap.appendChild(groupBox({ id: g.id, locked: g.locked, travelers: list }));
      });
      wireDrop(pool);
    }

    async function lockGroup(id){
      const trip_id = tripIdEl.value.trim(); const date = dateEl.value.trim();
      const box = groupsWrap.querySelector(`.group[data-id="${CSS.escape(id)}"]`);
      const emails = [...box.querySelectorAll('.trav')].map(el => el.dataset.email);
      const r = await fetch('/admin/groups', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ op: 'update', id, trip_id, date, travelers: emails, lock: true }) });
      if (r.ok) { alert('Locked'); load(); } else { alert('Lock failed'); }
    }

    document.getElementById('load').addEventListener('click', load);
    document.getElementById('newGroup').addEventListener('click', async ()=>{
      const trip_id = tripIdEl.value.trim(); const date = dateEl.value.trim();
      const r = await fetch('/admin/groups', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ op: 'create', trip_id, date, travelers: [] }) });
      if (r.ok) load(); else alert('Create failed');
    });

    document.getElementById('auto').addEventListener('click', async ()=>{
      const trip_id = tripIdEl.value.trim(); const date = dateEl.value.trim();
      if (!trip_id || !date) return alert('Fill trip_id and date');
      // Load travelers
      const r = await fetch(`/admin/groups?trip_id=${encodeURIComponent(trip_id)}&date=${encodeURIComponent(date)}`, { headers: { 'Accept': 'application/json' } });
      const j = await r.json();
      const poolTravs = j.travelers || [];
      // Build pairwise score matrix using existing /admin/suggest-pairs
      const p = await fetch(`/admin/suggest-pairs?trip_id=${encodeURIComponent(trip_id)}&date=${encodeURIComponent(date)}`, { headers: { 'Accept': 'application/json' } });
      const pairs = await p.json();
      const score = {};
      pairs.forEach(({a,b,score:s})=>{ score[`${a}|${b}`]=s; score[`${b}|${a}`]=s; });
      const emails = poolTravs.map(t=>t.email);

      // Greedy grouping 5–7 per van: pick seed with highest avg score, then add best-next until 7, repeat
      const remaining = new Set(emails);
      async function createGroup(){
        if (remaining.size===0) return null;
        // Seed: traveler with highest sum of scores to others
        let seed = null, bestSum = -Infinity;
        for (const e of remaining) {
          let s = 0; for (const o of remaining) if (o!==e) s += (score[`${e}|${o}`]||0);
          if (s>bestSum) { bestSum=s; seed=e; }
        }
        if (!seed) return null;
        const group = [seed]; remaining.delete(seed);
        while (group.length < 7) {
          // choose candidate that maximizes average score to current group
          let cand = null, best = -Infinity;
          for (const e of remaining) {
            const avg = group.reduce((acc,g)=>acc+(score[`${e}|${g}`]||0),0)/group.length;
            if (avg>best) { best=avg; cand=e; }
          }
          if (!cand) break;
          // Ensure minimum cohesion threshold once size >=5
          if (group.length>=5 && best<0) break;
          group.push(cand); remaining.delete(cand);
        }
        // If group smaller than 5 and there are remaining, try one more even if threshold negative
        while (group.length<5 && remaining.size){ const e = remaining.values().next().value; group.push(e); remaining.delete(e); }
        return group;
      }

      // Clear existing groups
      groupsWrap.innerHTML='';
      // Create groups in UI
      const built = [];
      while (remaining.size){ const g = await createGroup(); if (!g) break; built.push(g); }
      built.forEach(arr=>{
        const list = arr.map(email => poolTravs.find(t=>t.email===email) || { email });
        groupsWrap.appendChild(groupBox({ id:null, locked:false, travelers:list }));
      });
      // Remove assigned from pool
      const assigned = new Set(built.flat());
      pool.innerHTML='';
      poolTravs.filter(t=>!assigned.has(t.email)).forEach(t => pool.appendChild(travItem(t)));
    });

    // Initial load if params present
    if (tripIdEl.value && dateEl.value) { load(); }
  })();
  </script>
</body>
</html>
